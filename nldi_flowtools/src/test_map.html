

<!DOCTYPE html>
<html>
<head>
	
	<title>StreamStats open source delineation</title>

	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.5.1/dist/leaflet.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.css"/>
    <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/leaflet@1.5.1/dist/leaflet.js" ></script>
    <script src="https://unpkg.com/esri-leaflet@2.3.0/dist/esri-leaflet.js" ></script>

    <script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.js"></script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/gokertanrisever/leaflet-ruler@master/src/leaflet-ruler.css" integrity="sha384-P9DABSdtEY/XDbEInD3q+PlL+BjqPCXGcF8EkhtKSfSTr/dS5PBKa9+/PMkW2xsY" crossorigin="anonymous">  
    <script src="https://cdn.jsdelivr.net/gh/gokertanrisever/leaflet-ruler@master/src/leaflet-ruler.js" integrity="sha384-N2S8y7hRzXUPiepaSiUvBH1ZZ7Tc/ZfchhbPdvOE5v3aBBCIepq9l+dBJPFdo1ZJ" crossorigin="anonymous"></script>

    <!-- Easy Button -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-easybutton@2/src/easy-button.css">
    <script src="https://cdn.jsdelivr.net/npm/leaflet-easybutton@2/src/easy-button.js"></script>
    <!-- Slider  -->
    <link rel="stylesheet" href="http://eclipse1979.github.io/leaflet.slider/dist/leaflet-slider.css">
    <script src="http://eclipse1979.github.io/leaflet.slider/dist/leaflet-slider.js"></script>

    <!-- <script src="https://leaflet.github.io/Leaflet.draw/docs/examples-0.7.x/libs/leaflet-src.js"></script>  
    <link rel="stylesheet" href="https://leaflet.github.io/Leaflet.draw/docs/examples-0.7.x/libs/leaflet.css"/> -->

    <script src="https://leaflet.github.io/Leaflet.draw/src/Leaflet.draw.js"></script>
    <script src="https://leaflet.github.io/Leaflet.draw/src/Leaflet.Draw.Event.js"></script>
    <link rel="stylesheet" href="https://leaflet.github.io/Leaflet.draw/src/leaflet.draw.css"/>

    <script src="https://leaflet.github.io/Leaflet.draw/src/Toolbar.js"></script>
    <script src="https://leaflet.github.io/Leaflet.draw/src/Tooltip.js"></script>

    <script src="https://leaflet.github.io/Leaflet.draw/src/ext/GeometryUtil.js"></script>
    <script src="https://leaflet.github.io/Leaflet.draw/src/ext/LatLngUtil.js"></script>
    <script src="https://leaflet.github.io/Leaflet.draw/src/ext/LineUtil.Intersect.js"></script>
    <script src="https://leaflet.github.io/Leaflet.draw/src/ext/Polygon.Intersect.js"></script>
    <script src="https://leaflet.github.io/Leaflet.draw/src/ext/Polyline.Intersect.js"></script>
    <script src="https://leaflet.github.io/Leaflet.draw/src/ext/TouchEvents.js"></script>

    <script src="https://leaflet.github.io/Leaflet.draw/src/draw/DrawToolbar.js"></script>
    <script src="https://leaflet.github.io/Leaflet.draw/src/draw/handler/Draw.Feature.js"></script>
    <script src="https://leaflet.github.io/Leaflet.draw/src/draw/handler/Draw.SimpleShape.js"></script>
    <script src="https://leaflet.github.io/Leaflet.draw/src/draw/handler/Draw.Polyline.js"></script>
    <script src="https://leaflet.github.io/Leaflet.draw/src/draw/handler/Draw.Marker.js"></script>
    <script src="https://leaflet.github.io/Leaflet.draw/src/draw/handler/Draw.Circle.js"></script>
    <script src="https://leaflet.github.io/Leaflet.draw/src/draw/handler/Draw.CircleMarker.js"></script>
    <script src="https://leaflet.github.io/Leaflet.draw/src/draw/handler/Draw.Polygon.js"></script>
    <script src="https://leaflet.github.io/Leaflet.draw/src/draw/handler/Draw.Rectangle.js"></script>

    <script src="https://leaflet.github.io/Leaflet.draw/src/edit/EditToolbar.js"></script>
    <script src="https://leaflet.github.io/Leaflet.draw/src/edit/handler/EditToolbar.Edit.js"></script>
    <script src="https://leaflet.github.io/Leaflet.draw/src/edit/handler/EditToolbar.Delete.js"></script>

    <script src="https://leaflet.github.io/Leaflet.draw/src/Control.Draw.js"></script>

    <script src="https://leaflet.github.io/Leaflet.draw/src/edit/handler/Edit.Poly.js"></script>
    <script src="https://leaflet.github.io/Leaflet.draw/src/edit/handler/Edit.SimpleShape.js"></script>
    <script src="https://leaflet.github.io/Leaflet.draw/src/edit/handler/Edit.Rectangle.js"></script>
    <script src="https://leaflet.github.io/Leaflet.draw/src/edit/handler/Edit.Marker.js"></script>
    <script src="https://leaflet.github.io/Leaflet.draw/src/edit/handler/Edit.CircleMarker.js"></script>
    <script src="https://leaflet.github.io/Leaflet.draw/src/edit/handler/Edit.Circle.js"></script>

    <script src="https://8to5developer.github.io/leaflet-custom-searchbox/dist/leaflet.customsearchbox.min.js"></script>
    <link href="https://8to5developer.github.io/leaflet-custom-searchbox/dist/searchbox.min.css" rel="stylesheet" />



	<style>

        body {
            font-family: 'Roboto', sans-serif;
            padding: 0;
            margin: 0;
        }
        html, body, #map {
            height: 100%;
            width: 100%;
        }

        .leaflet-control-layers:hover {
            cursor: pointer;
        }

        body.delineate * { cursor: crosshair; }
	</style>
</head>
<body>

<div id='map'></div>

<script>
var map;
var startPoint, border, catchment, splitCatchment, upstreamBasin, mergedCatchment;
var intersectionPoint, raindropPath, nhdFlowline, upstreamFlowline, downstreamFlowline, downstreamPath;
var features;
var layerControl;
var loadingToast;
var startTime;
var runsplitcatchment = true;
var query_polygon = false;
var getFlowlines = 'True';
var runxstool = false;
var truefalse = 'True';
var direction = 'down';
var payload;
var poly_coords;
var processing_json = false;
var downstream_dist = 0;

//main document ready function
$(document).ready(function () {

    toastr.options = {
        "positionClass": "toast-bottom-right",
    }
    
    var basemap = L.esri.basemapLayer('NationalGeographic')
    var statmap = L.esri.basemapLayer('Imagery')
    //show str900 grid
    streamGridLayer = L.esri.dynamicMapLayer({
        url: 'https://gis.streamstats.usgs.gov/arcgis/rest/services/StreamStats/stateServices/MapServer',
        layers: [41] // MN; 69, ND; 87, SD: 120
    }) //.addTo(map);

// NHD_FLOWLINES_URL = 'https://labs.waterdata.usgs.gov/geoserver/wmadata/ows?service=wfs&version=1.0.0&request=GetFeature&typeName=wmadata%3Anhdflowline_network&maxFeatures=500&outputFormat=application%2Fjson&srsName=EPSG%3A4326&CQL_FILTER=comid%3D'


	//initialize map
	map = new L.Map('map', {
		center: new L.LatLng(41.75, -93),
		zoom: 7,
		layers: basemap,
		attributionControl: false,
        zoomControl: false
	}); 

    var flowtoolsButton = L.easyButton(
        {
            states: [{
                stateName: 'flowtools_off',        // name the state
                icon:      '<strong>On</strong>',               // and define its properties
                title:     'Flowtools off',      // like its title
                onClick: function(control) {       // and its callback
                    control.state('flowtools_on');
                    map.off('click', delineatePoint);
                }
            }, {
                stateName: 'flowtools_on',
                icon:      '<strong>Off</strong>',
                title:     'Flowtools on',
                onClick: function(control) {
                    control.state('flowtools_off');
                    map.on('click', delineatePoint);
                }
            }
        ]
    })

    flowtoolsButton.addTo(map);

    var shapeQueryButton = L.easyButton(
        {
            states: [{
                stateName: 'point',
                icon:       '<strong>Point</strong>',
                title:      'Point Query',
                onClick: function(control) {
                    control.state('polygon');
                    map.off('click', delineatePoint);
                    query_polygon = true;
                    functionButton.remove(map);
                    truefalseButton.remove(map);
                    getFlowlinesButton.addTo(map);
                    map.addControl(drawControl);
                    slider.addTo(map);
                    map.removeControl(searchbox);
                    // point_submit.remove(map);
                    poly_submit.addTo(map);
                    // upload.addTo(map);
                }
            }, {
                stateName: 'polygon',
                icon:       '<strong>Polygon</strong>',
                title:      'Polygon Query',
                onClick: function(control) {
                    control.state('point');
                    map.on('click', delineatePoint);
                    // point_submit.addTo(map);
                    poly_submit.remove(map);
                    query_polygon = false;
                    functionButton.addTo(map);
                    truefalseButton.addTo(map);
                    map.removeControl(drawControl);
                    map.addControl(searchbox);
                    getFlowlinesButton.remove(map);
                    slider.remove(map);
                    // upload.remove(map);
                }
            }
        ]
    });
    shapeQueryButton.button.style.width = '70px';
    shapeQueryButton.addTo(map);

    var getFlowlinesButton = L.easyButton(
        {
            states: [{
                stateName: 'yes',
                icon: '<strong>Get Flowlines Basins</strong>',
                title: 'Get Flowlines Basins',
                onClick: function(control) {
                    control.state('no');
                    getFlowlines = 'False';
                    slider.remove(map);
                }
            }, {
                stateName: 'no',
                icon: '<strong>No Flowlines Basins</strong>',
                title: 'No Flowlines Basins',
                onClick: function(control) {
                    control.state('yes');
                    getFlowlines = 'True';
                    slider.addTo(map);
                }
            }
            ]
        }
    )
    getFlowlinesButton.button.style.width = '150px';

    slider = L.control.slider(function(value) {
        // console.log('downstream_dist,', downstream_dist);
        downstream_dist = value;
        // console.log('downstream_dist,', downstream_dist);
            }, {
            max: 1000,
            value: 0,
            step: 10,
            size: '250px',
            orientation:'vertical',
            id:'slider',
            position:'topleft'
        });

    var functionButton = L.easyButton(
        {
            states: [{
                stateName: 'run-splitcatchment',        // name the state
                icon:      '<strong>Splitcatchment</strong>',               // and define its properties
                // title:     'Splitcatchment',      // like its title
                onClick: function(control) {       // and its callback
                    control.state('run-flowtrace');
                    runsplitcatchment = false ;   // change state on click!
                    directionButton.addTo(map);
                    
                }
            }, {
                stateName: 'run-flowtrace',
                icon:      '<strong>Flowtrace</strong>',
                // title:     'Flowtrace',
                onClick: function(control) {
                    control.state('run-splitcatchment');                    
                    runsplitcatchment = true;
                    directionButton.remove(map);
                    // truefalseButton.remove(map);
                }
            }
        ]
    });
    functionButton.button.style.width = '110px';
    functionButton.addTo(map);

    var truefalseButton = L.easyButton(
        {
            states: [{
                stateName: 'true',        // name the state
                icon:      '<strong>True</strong>',               // and define its properties
                // title:     'True',      // like its title
                onClick: function(control) {       // and its callback
                    control.state('false');
                    truefalse = 'False' ;   // change state on click!
                }
            }, {
                stateName: 'false',
                icon:      '<strong>False</strong>',
                // title:     'False',
                onClick: function(control) {
                    control.state('true');
                    truefalse = 'True';
                }
            }]
    });
    truefalseButton.button.style.width = '50px';
    truefalseButton.addTo(map);

    var directionButton = L.easyButton(
        {
            states: [{
                stateName:  'down',
                icon:       '<strong>Downstream</strong>',
                // title:      'Downstream',
                onClick: function(control) {
                    control.state('up');
                    direction = 'up';
                }
            },{
                stateName:  'up',
                icon:       '<strong>Upstream</strong>',
                // title:      'Upstream',
                onClick: function(control) {
                    control.state('none');
                    direction = 'none';
                }
            },{
                stateName:  'none',
                icon:       '<strong>Entire</strong>',
                // title:      'Entire',
                onClick: function(control) {
                    control.state('down');
                    direction = 'down';
                }

            }]

    });
    directionButton.button.style.width = '100px';

    var drawnItems = L.featureGroup().addTo(map);

    layerControl = L.control.layers({
        ' Basemap': basemap
    }, { 'drawlayer': drawnItems }, { position: 'topright', collapsed: false }).addTo(map);
    
    var drawControl = new L.Control.Draw({
        // draw: false,
        edit: {
            featureGroup: drawnItems,
            poly: {
                allowIntersection: false
            }
        },
        draw: {
            polygon: {
                allowIntersection: false,
                showArea: true
            },
            circle: false,
            marker: false,
            polyline: false,
            rectangle: false,
            circlemarker: false
        }
    });
    

    map.on(L.Draw.Event.CREATED, function (event) {
        var layer = event.layer;
        console.log('layer:', event)
        drawnItems.addLayer(layer);
        // console.log('layer coords ',layer.getLatLngs());
        poly_coords = layer.toGeoJSON().geometry.coordinates;
        // console.log('poly_coords ', poly_coords, typeof(poly_coords));
        poly_coords = [].concat.apply([], layer.toGeoJSON().geometry.coordinates);
        // console.log('poly_coords ', poly_coords, typeof(poly_coords));
    });

    var searchboxControl=createSearchboxControl();
    var searchbox = new searchboxControl({ });
        searchbox._searchfunctionCallBack = function (searchkeywords)
        {
            console.log(searchkeywords, typeof(searchkeywords));
            delineatePoint(searchkeywords);
        }

    map.addControl(searchbox);
    var div = document.getElementById('searchbox-menubutton');
    div.remove();

    var upload = L.control({'position':'bottomleft'});
    upload.onAdd = function (map) {
        this._div = L.DomUtil.create('div', 'upload');
        this._div.innerHTML = '<input type="file" id="file-selector"/>'; // /n <ul id="output"></ul>
        return this._div;
    };
    upload.addTo(map);

    if (window.FileList && window.File) {
        document.getElementById('file-selector').addEventListener('change', event => {   
            var file = document.getElementById("file-selector").files[0];
            if (file) {
                processing_json = true;
                const reader = new FileReader();
                reader.addEventListener('load', (event) => {                    
                    var data = JSON.parse(event.target.result);
                    // console.log('data:', typeof(data), data)
                    if (data.features.length > 1) {
                        // console.log('multipolygon')
                        poly_coords = []
                        for (x in data.features) {
                            // console.log('coords to add:', data.features[x].geometry.coordinates)
                            poly_coords.push(data.features[x].geometry.coordinates)
                        }
                    }
                    else if (data.features.length == 1) {
                        // console.log('Single Polygon')
                        poly_coords = [data.features.geometry.coordinates]
                    }
                    else {
                        console.log('Cannot read geometry from JSON file')
                    }
                    var input_geom = L.geoJSON(data)
                    layerControl.addOverlay(input_geom , "Polygon");
                    input_geom.addTo(map);
                    delineatePoint(data)
                });
                reader.readAsText(file);
            }
        }); 
    }

    var poly_submit = L.easyButton({
        states: [{
            stateName: 'submit',
            icon:       '<strong>Submit</strong>',
            onClick: function() {
                delineatePoint(drawnItems)
            }
        }]
    });
    poly_submit.button.style.width = '70px';

    var options = {
      position: 'topright',         // Leaflet control position option
      circleMarker: {               // Leaflet circle marker options for points used in this plugin
        color: 'red',
        radius: 2
      },
      lineStyle: {                  // Leaflet polyline options for lines used in this plugin
        color: 'red',
        dashArray: '1,6'
      },
      lengthUnit: {                 // You can use custom length units. Default unit is kilometers.
        display: 'm',              // This is the display value will be shown on the screen. Example: 'meters'
        decimal: 2,                 // Distance result will be fixed to this value. 
        factor: 1000,               // This value will be used to convert from kilometers. Example: 1000 (from kilometers to meters)  
        label: 'Distance:'           
      },
      angleUnit: {
        display: '&deg;',           // This is the display value will be shown on the screen. Example: 'Gradian'
        decimal: 2,                 // Bearing result will be fixed to this value.
        factor: null,                // This option is required to customize angle unit. Specify solid angle value for angle unit. Example: 400 (for gradian).
        label: 'Bearing:'
      }
    }
    L.control.ruler(options).addTo(map);


    // var hydro = L.esri.dynamicMapLayer({
    //     'url': 'https://hydro.nationalmap.gov/arcgis/rest/services/nhd/MapServer',
    //     'layers': [5,6]
    // }).addTo(map);

    // var hydro2 = L.tileLayer.wms('https://labs.waterdata.usgs.gov/geoserver/wmadata/ows', {layers: 'nhdflowline_network', transparent: true, format: 'image/png'})
    var hydro3 = L.tileLayer.wms('https://labs.waterdata.usgs.gov/geoserver/gwc/service/', {layers: 'wmadata:nhdflowline_network', transparent: true,  format: 'image/png'})  //transparent: true,
    

    // layerControl.addOverlay(basemap, "Nat Geo");
    layerControl.addOverlay(streamGridLayer , "str900");
    layerControl.addOverlay(statmap, 'Satellite Imagery');
    // layerControl.addOverlay(hydro2 , "Old NLDI Hydro");
    layerControl.addOverlay(hydro3 , "NLDI Hydro");
    

    //container featuregroup used for zooming
    features = L.featureGroup();

    map.on('zoomend', changeCursor );

    //click listener for delineation start
    map.on('click', delineatePoint)
    
    
});

function changeCursor() {
    if (map.getZoom() >= 4) {
        console.log('ready to delineate')    
        document.body.classList.add('delineate');
    }
    else {
        document.body.classList.remove('delineate');
    }
}


function delineatePoint(e) {

    console.log('e: ', e)

    startTime = performance.now();
    loadingToast = toastr.info('Delineating wastershed...', {timeOut: 0});

    features.clearLayers();
    if (startPoint) { 
        layerControl.removeLayer(startPoint);
        map.removeLayer(startPoint)
    }
    if (catchment) {
        layerControl.removeLayer(catchment);
        map.removeLayer(catchment)
    }
    if (splitCatchment) {
        layerControl.removeLayer(splitCatchment);
        map.removeLayer(splitCatchment)
    }
    if (upstreamBasin) {
        layerControl.removeLayer(upstreamBasin);
        map.removeLayer(upstreamBasin)
    }
    if (mergedCatchment) {
        layerControl.removeLayer(mergedCatchment);
        map.removeLayer(mergedCatchment)
    }
    if (intersectionPoint) {
        layerControl.removeLayer(intersectionPoint);
        map.removeLayer(intersectionPoint)
    }
    if (raindropPath) {
        layerControl.removeLayer(raindropPath);
        map.removeLayer(raindropPath)
    }
    if (nhdFlowline) {
        layerControl.removeLayer(nhdFlowline);
        map.removeLayer(nhdFlowline)
    }
    if (upstreamFlowline) {
        layerControl.removeLayer(upstreamFlowline);
        map.removeLayer(upstreamFlowline)
    }
    if (downstreamFlowline) {
        layerControl.removeLayer(downstreamFlowline);
        map.removeLayer(downstreamFlowline)
    }
    if (downstreamPath) {
        layerControl.removeLayer(downstreamPath);
        map.removeLayer(downstreamPath)
    }
// If the query is for a point...
    if (e.latlng) {
        var data =  {  
            lat: e.latlng.lat,
            lng: e.latlng.lng
        };
        var payload = {
        lat: data.lat,
        lng: data.lng,
        query_polygon: query_polygon,
        runsplitcatchment: runsplitcatchment,
        truefalse: truefalse,
        direction: direction,
        }
    }
// If the query is for a drawn polygon...
    else if (typeof(e) == 'string') {
        var data = JSON.parse("[" + e + "]")
        if (Math.sign(data[0]) == -1) { data = [data[1], data[0]] }
        var payload = {
        lat: data[0],
        lng: data[1],
        query_polygon: query_polygon,
        runsplitcatchment: runsplitcatchment,
        truefalse: truefalse,
        direction: direction,
        downstream_dist: downstream_dist
        }

        startPoint = L.marker([data[0],data[1]]).addTo(map);   
        startPoint.bindPopup('<b>Click point: </b>' + '<br>' +data[1] + ', ' + data[0] + '</br>').openPopup();
    }
// If the query is for data inported from a json file...
    else if (processing_json) {
        // console.log('poly_coords;', poly_coords);
        var data = JSON.stringify(poly_coords);
        // console.log('data;', data);
        var payload = {
            lnglat: data,
            query_polygon: query_polygon,
            getFlowlines: getFlowlines,
            downstream_dist: downstream_dist
        }
    }

    else {
        console.log('poly_coords;', typeof(poly_coords), poly_coords);
        console.log('downstream_dist,', downstream_dist);
        var data = '[['+ poly_coords.join('],[') + ']]' //[].concat.apply([], poly_coords);
        // data = data.join();
        console.log('data:', data, typeof(data));
        
        var payload = {
            lnglat: data,
            query_polygon: query_polygon,
            getFlowlines: getFlowlines,
            downstream_dist: downstream_dist
        }
    }

    

    // console.log('payload: ', payload)

    if (e.latlng) {
        startPoint = L.marker([data.lat,data.lng]).addTo(map);   
        startPoint.bindPopup('<b>Click point: </b>' + '<br>' +data.lng + ', ' + data.lat + '</br>').openPopup();
    }

    $.ajax({ 
        url: 'http://127.0.0.1:5000/flowtools',
        type: 'GET',
        dataType: 'json', // added data type
        data: payload,
        success: function (resData) {   // success callback function
            console.log('response:', resData) 

            res = resData['features'];

            toastr.clear(loadingToast);
            var endTime = performance.now();
            var totalTime = (endTime - startTime)/1000;
            toastr.info('It took ' + totalTime.toFixed(2) + ' seconds.');

            if (res[0]['id'] == 'catchment') {
                // console.log('has Catchment', res[0]['geometry'])
                catchment = L.geoJson(res[0]['geometry'], { style: function(feature) {
                    return {
                        fillColor: 'yellow',
                        weight: 2,
                        opacity: 1,
                        color: 'orange',  //Outline color
                        fillOpacity: 0.7         
                    }    
                }}).addTo(map);
                catchment.addTo(features)
                layerControl.addOverlay(catchment , "Catchment");

            }

            
            if (res[0]['id'] == 'nhdFlowline') {
                    //console.log('has nhdFlowline', res.nhdFlowline)
                    nhdFlowline = L.geoJson(res[0]['geometry'], { style: function(feature) {
                        return {
                            fillColor: 'yellow',
                            weight: 2,
                            opacity: 1,
                            color: 'yellow',  //Outline color
                            fillOpacity: 0.2        
                        }    
                    }}).addTo(map);
                    nhdFlowline.addTo(features)
                    layerControl.addOverlay(nhdFlowline , "NHD Flowlines");
                    nhdFlowline.bindPopup('<b>Stream name: </b>' + res[0]['properties']['gnis_name'] +
                                            '<br><b>Comid: </b>' + res[0]['properties']['comid'] + '</br>' +
                                            '<b>Reach Code: </b>' + res[0]['properties']['reachcode'] +
                                            '<br><b>Measure: </b> 0:' + res[0]['properties']['measure'] + '</br>' +
                                            '<b>Raindrop Path Length: </b>' + res[0]['properties']['raindropPathDist'] + ' meters' +
                                            '<br><b>Intersection Point: </b>' + res[0]['properties']['intersectionPoint'][0] + ', ' + res[0]['properties']['intersectionPoint'][1] + '</br>').openPopup();

                }
                
                if (res[0]['id'] == 'upstreamFlowline') {
                    // console.log('has upstreamFlowline', res.upstreamFlowline)
                    upstreamFlowline = L.geoJson(res[0]['geometry'], { style: function(feature) {
                        return {
                            fillColor: 'yellow',
                            weight: 2,
                            opacity: 1,
                            color: 'yellow',  //Outline color
                            fillOpacity: 0.2        
                        }    
                    }}).addTo(map);
                    upstreamFlowline.addTo(features)
                    layerControl.addOverlay(upstreamFlowline , "Upstream Flowlines");
                    upstreamFlowline.bindPopup('<b>Stream name: </b>' + res[0]['properties']['gnis_name'] +
                                            '<br><b>Comid: </b>' + res[0]['properties']['comid'] + '</br>' +
                                            '<b>Reach Code: </b>' + res[0]['properties']['reachcode'] +
                                            '<br><b>Measure: </b> 0:' + res[0]['properties']['measure'] + '</br>' +
                                            '<b>Raindrop Path Length: </b>' + res[0]['properties']['raindropPathDist'] + ' meters' +
                                            '<br><b>Intersection Point: </b>' + res[0]['properties']['intersectionPoint'][0] + ', ' + res[0]['properties']['intersectionPoint'][1] + '</br>').openPopup();

                }

                if (res[0]['id'] == 'downstreamFlowline') {
                    // console.log('has downstreamFlowline', res.downstreamFlowline)
                    downstreamFlowline = L.geoJson(res[0]['geometry'], { style: function(feature) {
                        return {
                            fillColor: 'yellow',
                            weight: 2,
                            opacity: 1,
                            color: 'yellow',  //Outline color
                            fillOpacity: 0.2        
                        }    
                    }}).addTo(map);
                    downstreamFlowline.addTo(features)
                    layerControl.addOverlay(downstreamFlowline , "Downstream Flowlines");
                    downstreamFlowline.bindPopup('<b>Stream name: </b>' + res[0]['properties']['gnis_name'] +
                                            '<br><b>Comid: </b>' + res[0]['properties']['comid'] + '</br>' +
                                            '<b>Reach Code: </b>' + res[0]['properties']['reachcode'] +
                                            '<br><b>Measure: </b> 0:' + res[0]['properties']['measure'] + '</br>' +
                                            '<b>Raindrop Path Length: </b>' + res[0]['properties']['raindropPathDist'] + ' meters' +
                                            '<br><b>Intersection Point: </b>' + res[0]['properties']['intersectionPoint'][0] + ', ' + res[0]['properties']['intersectionPoint'][1] + '</br>').openPopup();

                }

                if (res[0]['id'] == 'downstreamPath') {
                    // console.log('has downstreamPath', res.downstreamPath)
                    downstreamPath = L.geoJson(item, { style: function(feature) {
                        return {
                            fillColor: 'purple',
                            weight: 2,
                            opacity: 1,
                            color: 'purple',  //Outline color
                            fillOpacity: 0.2        
                        }    
                    }}).addTo(map);
                    downstreamPath.addTo(features)
                    layerControl.addOverlay(downstreamPath , "Downstream Path");
                }

            if (res[1]['id'] == 'splitCatchment') {
                // console.log('has split Catchment', res[1]['geometry'])
                splitCatchment = L.geoJson(res[1]['geometry'], { style: function(feature) {
                    return {
                        fillColor: 'green',
                        weight: 2,
                        opacity: 1,
                        color: 'green',  //Outline color
                        fillOpacity: 0.7         
                    }    
                }}).addTo(map);
                splitCatchment.addTo(features)
                layerControl.addOverlay(splitCatchment , "Split Catchment");

            }

            if (res[1]['id'] == 'upstreamBasin') {
                console.log('has upstreamBasin', res[1]['geometry'])
                upstreamBasin = L.geoJson(res[1]['geometry'], { style: function(feature) {
                    return {
                        fillColor: 'red',
                        weight: 2,
                        opacity: 1,
                        color: 'red',  //Outline color
                        fillOpacity: 0.7         
                    }    
                }}).addTo(map);
                upstreamBasin.addTo(features)
                layerControl.addOverlay(upstreamBasin , "Upstream Basin");
                
            }


            if (res[1]['id'] == 'mergedCatchment') {
                //console.log('has merged Catchment', res.mergedCatchmentt)
                mergedCatchment = L.geoJson(res[1]['geometry'], { style: function(feature) {
                    return {
                        fillColor: 'blue',
                        weight: 2,
                        opacity: 1,
                        color: 'blue',  //Outline color
                        fillOpacity: 0.2        
                    }    
                }}).addTo(map);
                mergedCatchment.addTo(features)
                layerControl.addOverlay(mergedCatchment , "Merged Catchment");
            }
            
                // if (res.intersectionPoint) {
                //     //console.log('has intersectionPoint', res.intersectionPoint)
                //     intersectionPoint = L.geoJson(res.intersectionPoint).addTo(map);
                //     intersectionPoint.addTo(features)
                //     layerControl.addOverlay(intersectionPoint , "Intersection Point");

                //     intersectionPoint.bindPopup('<b>Stream name: </b>' + res.streamInfo.gnis_name +
                //                             '<br><b>Comid: </b>' + res.streamInfo.comid + '</br>' +
                //                             '<b>Reach Code: </b>' + res.streamInfo.reachcode +
                //                             '<br><b>Measure: </b> 0:' + res.streamInfo.measure + '</br>' +
                //                             '<b>Raindrop Path Length: </b>' + res.streamInfo.raindropPathDist + ' meters' +
                //                             '<br><b>Intersection Point: </b>' + res.intersectionPoint.coordinates[1] + ', ' + res.intersectionPoint.coordinates[0] + '</br>').openPopup();

                // }

                if (res[1]['id'] == 'raindropPath') {
                    // console.log('has raindropPath', res.raindropPath)
                    raindropPath = L.geoJson(res[1]['geometry'], { style: function(feature) {
                        return {
                            fillColor: 'blue',
                            weight: 2,
                            opacity: 1,
                            color: 'blue',  //Outline color
                            fillOpacity: 0.2        
                        }    
                    }}).addTo(map);
                    raindropPath.addTo(features)
                    layerControl.addOverlay(raindropPath , "Raindrop Path");
                }

                if (res[1]['id'] == 'flowlinesGeom') {
                    //console.log('has nhdFlowline', res.nhdFlowline)
                    nhdFlowline = L.geoJson(res[1]['geometry'], { style: function(feature) {
                        return {
                            fillColor: 'blue',
                            weight: 2,
                            opacity: 1,
                            color: 'blue',  //Outline color
                            fillOpacity: 0.2        
                        }    
                    }}).addTo(map);
                    nhdFlowline.addTo(features)
                    layerControl.addOverlay(nhdFlowline , "NHD Flowlines");
                    
                }

                if (res[2]){
                    if (res[2]['id'] == 'flowlinesGeom') {
                        //console.log('has nhdFlowline', res.nhdFlowline)
                        nhdFlowline = L.geoJson(res[2]['geometry'], { style: function(feature) {
                            return {
                                fillColor: 'blue',
                                weight: 2,
                                opacity: 1,
                                color: 'blue',  //Outline color
                                fillOpacity: 0.2        
                            }    
                        }}).addTo(map);
                        nhdFlowline.addTo(features)
                        layerControl.addOverlay(nhdFlowline , "NHD Flowlines");
                        
                    }
                }
                
            
            //console.log('features:',features)
            map.fitBounds(features.getBounds());
            
        },
        error: function (jqXHR, status, err) {
            console.log("Local error callback.", status, err);
            toastr.clear(loadingToast);
            toastr.error('There was a problem with the request', {timeOut: 0});
        },
        complete: function() {
            // console.log('after delineate:', data)

            //update URL in address bar even on fail
        //     window.history.pushState('delineate', 'nldi-delineate', './?lat=' + data.lat + '&lng=' + data.lng);
         }

    });


}


</script>
</body>
</html>